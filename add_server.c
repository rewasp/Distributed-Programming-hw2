/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "add.h"

#define ADD 43
#define SUB 45
#define MUL 42
#define DIV 47


int calculate(char *, double *, int);

int * arithmetic_1_svc(equation *argp, struct svc_req *rqstp)
{
	static int  result;
    char *op;
    double *num;
    int op_num=0;
    int i, num_in=0 
    , op_flag=1, minus_flag=0, factor=1; 
    int op_in=0;
    int len = strlen(argp->input);
    
    op = (char *)malloc(sizeof(char)*(len/2));
    num = (double *)malloc(sizeof(double)*(len/2)+1);
    
    for(i=0;i<(len/2)+1;i++){
        num[i] = 0;
    }
    i=0;

    while(i<len){
        /* operator */

        if(argp->input[i]<48 || argp->input[i]>57){
            
            switch(argp->input[i]){
                case ADD:
                    LOG_V("Getting Add op!\n");
                    op[op_in] = '+';

                    break;
                
                case SUB:
                    
                    if(op_flag){
                        LOG_V("getting minus flag!\n");
                        minus_flag = 1;
                        break;
                    }

                    LOG_V("Getting SUB op!\n");
                    op[op_in] = '-';

                    break;
                
                case MUL:
                    LOG_V("Getting MUL op!\n");
                    op[op_in] = '*';
            
                    break;

                case DIV:
                    LOG_V("Getting DIV op!\n");
                    op[op_in] = '/';

                    break;

                default:
                    printf("watch out! invalid input is given!\n");
                    break;
            }
                op_flag = 1;
                op_in++;

              //  LOG_V("op_in increased\n");
                if(minus_flag){
                    op_flag = 0;
                    op_in--;
                }
                
        }

        /* number */
        else{
            num[num_in] *= factor;
            
            num[num_in] += ((argp->input[i]) - 48);
            factor = 10;
            
            /* if minus_flag is on, consider it as negative integer */
            if(argp->input[i+1]<48){
                if(minus_flag){
                    num[num_in] *= -1;
                    minus_flag ^= 1;
                }
                factor = 1;
                num_in++;
                LOG_V("current num is %lf\n",num[num_in]);
            }
            op_flag = 0;
        }

        i++;
    }
    /* Calculate the given equation */
    result = calculate(op, num, op_in);
    free(op);
    free(num);

	return &result;
}

int calculate(char *op, double *num, int op_in)
{
    int len;
    int i, j;
    double after_that=0;
    int after_flag=0;

    for(i=0;i<op_in;i++){
        printf("%c\n",op[i]);
    }

    len = op_in; // get number of operators
    LOG_V("Number of Operator is %d\n",len);
    for(i=0;i<len;i++){

            LOG_V("num[i] is %lf and num[i+1] is %lf\n", num[i], num[i+1]);

        switch(op[i]){
            LOG_V("operator: %c\n", op[i]);
            case ADD: 

                if(i<len-1){
                    if(op[i+1] == MUL || op[i+1] == DIV){
                        after_that = num[i]; // i.e) In a + b * c, save a for later summation
                        after_flag = 1;
                        LOG_V("After Flag Set at ADD, and its value is %lf\n", num[i]);
                        break;
                    }
                    
                }
                num[i+1] = num[i] + num[i+1];

                LOG_V("ADD: sum is %lf\n", num[i+1]);

                break;

            case SUB:

                if(i<len-1){
                    if(op[i+1] == MUL || op[i+1] == DIV){
                        after_that = num[i]; // i.e) In a + b * c, save a for later summation
                        after_flag = 2;
                        LOG_V("After Flag Set at ADD, and its value is %lf\n", num[i]);
                        break;
                    }
                    
                }
                num[i+1] = num[i] - num[i+1];

                LOG_V("SUB: sum is %lf\n", num[i+1]);

                break;

            case MUL:
                num[i+1] = num[i] * num[i+1];


                if(after_flag){
                    LOG_V("after_flag entered!\n");
                    if(after_flag==1) num[i+1] += after_that;
                    else num[i+1] = (after_that - num[i+1]);
                }

                LOG_V("MUL: sum is %lf\n", num[i+1]);
                break;
            
            case DIV:
                if(num[i+1] == 0){
                    perror("Division by zero is not allowed!!\n");
                    exit(0);
                }

                num[i+1] = num[i] / num[i+1];

                 if(after_flag){
                    LOG_V("after_flag entered!\n");
                    if(after_flag==1) num[i+1] += after_that;
                    else num[i+1] = (after_that - num[i+1]);
                }

                LOG_V("DIV: sum is %lf\n", num[i+1]);
                break;

            default:

                break;

        } // end of switch statement

    }
    printf("final result is %lf\n",num[i]);
    return num[i];
}
